[{"categories":["java工具"],"content":"IDEA使用设置 继续idea最新安装的步骤后，对IDEA工作开发进行配置，让开发的时候更加便利顺手。 点击欢迎页右下角\"Configure\"，选择\"Settings\"，进入全局设置界面。 注意：IDEA有全局配置和项目配置两种设置，在欢迎页进行的Settings是对全局配置进行设置。而在项目中setting有可能为当前项目 ","date":"2020-12-22","objectID":"/idea/:0:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"一、 全局JDK设置（默认配置） 设置在：“Configure“下的“Structure for New Projects” 选择安装路径进行配置 ","date":"2020-12-22","objectID":"/idea/:1:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"二、主题设置 步骤前先点击setting:进入全局配置： ","date":"2020-12-22","objectID":"/idea/:2:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"进入全局配置 设置在：“File | Settings | Appearance \u0026 Behavior | Appearance“” ","date":"2020-12-22","objectID":"/idea/:2:1","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"三、字体大小设置 非代码窗口设置UI样式和字体 设置在：“File | Settings | Appearance \u0026 Behavior | Appearance”中 代码窗口字体 设置在：\"Editor“的”Font“中，分别设置编辑器字体、字号、行间距 设置控制台字体 控制台字体和编辑器字体设置一个逻辑，设置在：\"Editor“下”Color Scheme“的”Console Font“里。 ","date":"2020-12-22","objectID":"/idea/:3:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"四、字符集和配置文件编码格式设置 设置在：“File | Settings | Editor | File Encodings“ ","date":"2020-12-22","objectID":"/idea/:4:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"五、自动导入设置 设置在：“File | Settings | Editor | General | Auto Import” ","date":"2020-12-22","objectID":"/idea/:5:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"六、自动忽视大小写设置 设置在：“File | Settings | Editor | General | Code Completion” ","date":"2020-12-22","objectID":"/idea/:6:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"七、关闭自动更新设置以及每次打开项目为最后关闭项目 关闭自动更新 设置在： “File | Settings | Appearance \u0026 Behavior | System Settings | Updates” 2.关闭打开项目为最后关闭项目 设置在： “File | Settings | Appearance \u0026 Behavior | System Settings” ","date":"2020-12-22","objectID":"/idea/:7:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"八、Tab页多行显示设置 设置在：“File | Settings | Editor | General | Editor Tabs” ","date":"2020-12-22","objectID":"/idea/:8:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"九、滚轴修改字体大小设置以及代码悬浮提示 设置在：“File | Settings | Editor | General” ","date":"2020-12-22","objectID":"/idea/:9:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"十、显示方法之间的分割线 设置在： “File | Settings | Editor | General | Appearance” ","date":"2020-12-22","objectID":"/idea/:10:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"十一、注释格式 Java注释优化代码注释前空格格式 设置在： “File | Settings | Editor | Code Style | Java” html\\xml 注释优化代码注释前空格格式 设置在： “File | Settings | Editor | Code Style | html/xml” ","date":"2020-12-22","objectID":"/idea/:11:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"十二、开启代码自动编译 设置在： ”File/Settings/Build,Execution,Deployment/Compiler“ ","date":"2020-12-22","objectID":"/idea/:12:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"十三、2.2. 快捷键配置(File/Settings/Keymap) 设置在：”File | Settings | Keymap“ ","date":"2020-12-22","objectID":"/idea/:13:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"“十四、去除idea自带的.iml文件，以及.idea文件夹” 设置在： ”File | Settings | Editor | File Types“ ","date":"2020-12-22","objectID":"/idea/:14:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"十五、IDEA中Maven配置 设置在： “File | Settings | Build, Execution, Deployment | Build Tools | Maven” ","date":"2020-12-22","objectID":"/idea/:15:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"十六、IDEA中代码检测警告提示等级设置 ","date":"2020-12-22","objectID":"/idea/:16:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["java工具"],"content":"十七、包展开设置 ","date":"2020-12-22","objectID":"/idea/:17:0","tags":["java","IDEA"],"title":"2020年最新-IDEA最详细配置（配图文收藏版配置) 转载","uri":"/idea/"},{"categories":["前端"],"content":"Vuex 介绍 Vuex 是一个专为Vue.js应用程序开发的状态管理模式。 它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生改变。 ","date":"2020-12-14","objectID":"/vue/:0:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"状态管理模式 介绍 new Vue({ // state data() { return { count: 0 } }, // view template: ` \u003cdiv\u003e{{ count }}\u003c/div\u003e `, // actions methods: { increment() { this.count++ } } }) 这个状态自管理应用包含以下几个部分： state，驱动应用的数据源； view，以声明方式将 state 映射到视图； actions，响应在 view 上的用户输入导致的状态变化。 以下是一个表示“单向数据流”理念的简单示意： 但是，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏： 多个视图依赖于同一状态。 来自不同视图的行为需要变更同一状态。 对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。 对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。 因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！ 通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护 Vuex 的使用场景 Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。 如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。 一个简单的 store 模式 就足够您所需了。但是， 如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。 引用 Redux 的作者 Dan Abramov 的话说就是： Flux 架构就像眼镜：您自会知道什么时候需要它。 简单的 store 模式 ","date":"2020-12-14","objectID":"/vue/:1:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"简单状态管理起步使用 经常被忽略的是，Vue 应用中原始 data 对象的实际来源——当访问数据对象时，一个 Vue 实例只是简单的代理访问。所以，如果你有一处需要被多个实例间共享的状态，可以简单地通过维护一份数据来实现共享： var sourceOfTruth = {} var vmA = new Vue({ data: sourceOfTruth }) var vmB = new Vue({ data: sourceOfTruth }) 现在当 sourceOfTruth 发生变更，vmA 和 vmB 都将自动地更新它们的视图。子组件们的每个实例也会通过 this.$root.$data 去访问。现在我们有了唯一的数据来源，但是，调试将会变为噩梦。任何时间，我们应用中的任何部分，在任何数据改变后，都不会留下变更过的记录。 为了解决这个问题，我们采用一个简单的 store 模式： var store = { debug: true, state: { message: 'Hello!' }, setMessageAction (newValue) { if (this.debug) console.log('setMessageAction triggered with', newValue) this.state.message = newValue }, clearMessageAction () { if (this.debug) console.log('clearMessageAction triggered') this.state.message = '' } } 需要注意，所有 store 中 state 的变更，都放置在 store 自身的 action 中去管理。这种集中式状态管理能够被更容易地理解哪种类型的变更将会发生，以及它们是如何被触发。当错误出现时，我们现在也会有一个 log 记录 bug 之前发生了什么。 此外，每个实例/组件仍然可以拥有和管理自己的私有状态： var vmA = new Vue({ data: { privateState: {}, sharedState: store.state } }) var vmB = new Vue({ data: { privateState: {}, sharedState: store.state } }) 重要的是，注意你不应该在 action 中 替换原始的状态对象 - 组件和 store 需要引用同一个共享对象，变更才能够被观察到。 核心概念 State Getters Mutations Actions Modules ","date":"2020-12-14","objectID":"/vue/:2:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"State ","date":"2020-12-14","objectID":"/vue/:3:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"单一状态树 Vuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个 “唯一数据源 SSOT ”而存在。 这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段， 在调试的过程中也能轻易地取得整个当前应用状态的快照。 单状态树和模块化并不冲突——在后面的章节里我们会讨论如何将状态和状态变更事件分布到各个子模块中。 存储在 Vuex 中的数据和 Vue 实例中的 data 遵循相同的规则，例如状态对象必须是纯粹 (plain) 的。 ","date":"2020-12-14","objectID":"/vue/:3:1","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"在 Vue 组件中获得 Vuex 状态 由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在 计算属性 中返回某个状态 // 创建一个 Counter 组件 const Counter = { template: `\u003cdiv\u003e{{ count }}\u003c/div\u003e`, computed: { count () { return store.state.count } } } 每当 store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。 然而，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。 Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）： const app = new Vue({ el: '#app', // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: { Counter }, template: ` \u003cdiv class=\"app\"\u003e \u003ccounter\u003e\u003c/counter\u003e \u003c/div\u003e ` }) 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。让我们更新下 Counter 的实现： const Counter = { template: `\u003cdiv\u003e{{ count }}\u003c/div\u003e`, computed: { count () { return this.$store.state.count } } } ","date":"2020-12-14","objectID":"/vue/:4:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"mapState 辅助函数 当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性 // 在单独构建的版本中辅助函数为 Vuex.mapState import { mapState } from 'vuex' export default { // ... computed: mapState({ // 箭头函数可使代码更简练 count: state =\u003e state.count, // 传字符串参数 'count' 等同于 `state =\u003e state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) { return state.count + this.localCount } }) } 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。 computed: mapState([ // 映射 this.count 为 store.state.count 'count' ]) ","date":"2020-12-14","objectID":"/vue/:4:1","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"对象展开运算符 mapState 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。 computed: { localComputed () { /* ... */ }, // 使用对象展开运算符将此对象混入到外部对象中 ...mapState({ // ... }) } ","date":"2020-12-14","objectID":"/vue/:5:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"组件仍然保有局部状态 使用 Vuex 并不意味着你需要将所有的状态放入 Vuex。虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。 Getter 有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数： computed: { doneTodosCount () { return this.$store.state.todos.filter(todo =\u003e todo.done).length } } 如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。 Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 Getter 接受 state 作为其第一个参数： const store = new Vuex.Store({ state: { todos: [ { id: 1, text: '...', done: true }, { id: 2, text: '...', done: false } ] }, getters: { doneTodos: state =\u003e { return state.todos.filter(todo =\u003e todo.done) } } }) ","date":"2020-12-14","objectID":"/vue/:6:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"通过属性访问 Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值： store.getters.doneTodos // -\u003e [{ id: 1, text: '...', done: true }] Getter 也可以接受其他 getter 作为第二个参数： getters: { // ... doneTodosCount: (state, getters) =\u003e { return getters.doneTodos.length } } store.getters.doneTodosCount // -\u003e 1 我们可以很容易地在任何组件中使用它： computed: { doneTodosCount () { return this.$store.getters.doneTodosCount } } 注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。 ","date":"2020-12-14","objectID":"/vue/:7:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"通过方法访问 你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。 getters: { // ... getTodoById: (state) =\u003e (id) =\u003e { return state.todos.find(todo =\u003e todo.id === id) } } store.getters.getTodoById(2) // -\u003e { id: 2, text: '...', done: false } 注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。 ","date":"2020-12-14","objectID":"/vue/:8:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"mapGetters 辅助函数 mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性 import { mapGetters } from 'vuex' export default { // ... computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) } } 如果你想将一个 getter 属性另取一个名字，使用对象形式： ...mapGetters({ // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount` doneCount: 'doneTodosCount' }) Mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数： const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment (state) { // 变更状态 state.count++ } } }) 你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法： store.commit('increment') ","date":"2020-12-14","objectID":"/vue/:9:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"提交载荷（Payload） 你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload） // ... mutations: { increment (state, n) { state.count += n } } store.commit('increment', 10) 在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读 // ... mutations: { increment (state, payload) { state.count += payload.amount } } store.commit('increment', { amount: 10 }) ","date":"2020-12-14","objectID":"/vue/:10:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"对象风格的提交方式 提交 mutation 的另一种方式是直接使用包含 type 属性的对象： store.commit({ type: 'increment', amount: 10 }) 当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变： mutations: { increment (state, payload) { state.count += payload.amount } } ","date":"2020-12-14","objectID":"/vue/:11:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"Mutation 需遵守 Vue 的响应规则 既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项： 最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该 使用 Vue.set(obj, 'newProp', 123), 或者 以新对象替换老对象。例如，利用对象展开运算符 我们可以这样写 ","date":"2020-12-14","objectID":"/vue/:12:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"使用常量替代 Mutation 事件类型 使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然： // mutation-types.js export const SOME_MUTATION = 'SOME_MUTATION' // store.js import Vuex from 'vuex' import { SOME_MUTATION } from './mutation-types' const store = new Vuex.Store({ state: { ... }, mutations: { // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) { // mutate state } } }) 用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。 ","date":"2020-12-14","objectID":"/vue/:13:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"Mutation 必须是同步函数 一条重要的原则就是要记住 mutation 必须是同步函数。为什么？请参考下面的例子： mutations: { someMutation (state) { api.callAsyncMethod(() =\u003e { state.count++ }) } } 现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。 ","date":"2020-12-14","objectID":"/vue/:14:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"在组件中提交 Mutation 你可以在组件中使用 this.$store.commit('xxx') 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store） import { mapMutations } from 'vuex' export default { // ... methods: { ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` }) } } ","date":"2020-12-14","objectID":"/vue/:15:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"下一步：Action 在 mutation 中混合异步调用会导致你的程序很难调试。例如，当你调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢？这就是为什么我们要区分这两个概念。在 Vuex 中，mutation 都是同步事务： store.commit('increment') // 任何由 \"increment\" 导致的状态变更都应该在此刻完成。 为了处理异步操作，让我们来看一看 Action。 Action Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 让我们来注册一个简单的 action： const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit('increment') } } }) Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。 actions: { increment ({ commit }) { commit('increment') } } ","date":"2020-12-14","objectID":"/vue/:16:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"分发 Action Action 通过 store.dispatch 方法触发： store.dispatch('increment') 乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作： actions: { incrementAsync ({ commit }) { setTimeout(() =\u003e { commit('increment') }, 1000) } } Actions 支持同样的载荷方式和对象方式进行分发： // 以载荷形式分发 store.dispatch('incrementAsync', { amount: 10 }) // 以对象形式分发 store.dispatch({ type: 'incrementAsync', amount: 10 }) 来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation： actions: { checkout ({ commit, state }, products) { // 把当前购物车的物品备份起来 const savedCartItems = [...state.cart.added] // 发出结账请求，然后乐观地清空购物车 commit(types.CHECKOUT_REQUEST) // 购物 API 接受一个成功回调和一个失败回调 shop.buyProducts( products, // 成功操作 () =\u003e commit(types.CHECKOUT_SUCCESS), // 失败操作 () =\u003e commit(types.CHECKOUT_FAILURE, savedCartItems) ) } } 注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。 ","date":"2020-12-14","objectID":"/vue/:17:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"在组件中分发 Action 你在组件中使用 this.$store.dispatch('xxx') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为store.dispatch调用（需要先在根节点注入 store）： import { mapActions } from 'vuex' export default { // ... methods: { ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` }) } } ","date":"2020-12-14","objectID":"/vue/:18:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"组合 Action Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？ 首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise： actions: { actionA ({ commit }) { return new Promise((resolve, reject) =\u003e { setTimeout(() =\u003e { commit('someMutation') resolve() }, 1000) }) } } 现在你可以： store.dispatch('actionA').then(() =\u003e { // ... }) 在另外一个 action 中也可以： actions: { // ... actionB ({ dispatch, commit }) { return dispatch('actionA').then(() =\u003e { commit('someOtherMutation') }) } } 最后，如果我们利用 async / await，我们可以如下组合 action： // 假设 getData() 和 getOtherData() 返回的是 Promise actions: { async actionA ({ commit }) { commit('gotData', await getData()) }, async actionB ({ dispatch, commit }) { await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) } } 一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。 Module 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割： const moduleA = { state: () =\u003e ({ ... }), mutations: { ... }, actions: { ... }, getters: { ... } } const moduleB = { state: () =\u003e ({ ... }), mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB } }) store.state.a // -\u003e moduleA 的状态 store.state.b // -\u003e moduleB 的状态 ","date":"2020-12-14","objectID":"/vue/:19:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"模块的局部状态 对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。 const moduleA = { state: () =\u003e ({ count: 0 }), mutations: { increment (state) { // 这里的 `state` 对象是模块的局部状态 state.count++ } }, getters: { doubleCount (state) { return state.count * 2 } } } 同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState： const moduleA = { // ... actions: { incrementIfOddOnRootSum ({ state, commit, rootState }) { if ((state.count + rootState.count) % 2 === 1) { commit('increment') } } } } 对于模块内部的 getter，根节点状态会作为第三个参数暴露出来： const moduleA = { // ... getters: { sumWithRootCount (state, getters, rootState) { return state.count + rootState.count } } } ","date":"2020-12-14","objectID":"/vue/:20:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"命名空间 默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。 如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如： const store = new Vuex.Store({ modules: { account: { namespaced: true, // 模块内容（module assets） state: () =\u003e ({ ... }), // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响 getters: { isAdmin () { ... } // -\u003e getters['account/isAdmin'] }, actions: { login () { ... } // -\u003e dispatch('account/login') }, mutations: { login () { ... } // -\u003e commit('account/login') }, // 嵌套模块 modules: { // 继承父模块的命名空间 myPage: { state: () =\u003e ({ ... }), getters: { profile () { ... } // -\u003e getters['account/profile'] } }, // 进一步嵌套命名空间 posts: { namespaced: true, state: () =\u003e ({ ... }), getters: { popular () { ... } // -\u003e getters['account/posts/popular'] } } } } } }) 启用了命名空间的 getter 和 action 会收到局部化的 getter，dispatch 和 commit。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 namespaced 属性后不需要修改模块内的代码。 ","date":"2020-12-14","objectID":"/vue/:21:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"在带命名空间的模块内访问全局内容（Global Assets） 如果你希望使用全局 state 和 getter，rootState 和 rootGetters 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。 若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。 modules: { foo: { namespaced: true, getters: { // 在这个模块的 getter 中，`getters` 被局部化了 // 你可以使用 getter 的第四个参数来调用 `rootGetters` someGetter (state, getters, rootState, rootGetters) { getters.someOtherGetter // -\u003e 'foo/someOtherGetter' rootGetters.someOtherGetter // -\u003e 'someOtherGetter' }, someOtherGetter: state =\u003e { ... } }, actions: { // 在这个模块中， dispatch 和 commit 也被局部化了 // 他们可以接受 `root` 属性以访问根 dispatch 或 commit someAction ({ dispatch, commit, getters, rootGetters }) { getters.someGetter // -\u003e 'foo/someGetter' rootGetters.someGetter // -\u003e 'someGetter' dispatch('someOtherAction') // -\u003e 'foo/someOtherAction' dispatch('someOtherAction', null, { root: true }) // -\u003e 'someOtherAction' commit('someMutation') // -\u003e 'foo/someMutation' commit('someMutation', null, { root: true }) // -\u003e 'someMutation' }, someOtherAction (ctx, payload) { ... } } } } ","date":"2020-12-14","objectID":"/vue/:22:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"在带命名空间的模块注册全局 action 若需要在带命名空间的模块注册全局 action，你可添加 root: true，并将这个 action 的定义放在函数 handler 中。例如 { actions: { someOtherAction ({dispatch}) { dispatch('someAction') } }, modules: { foo: { namespaced: true, actions: { someAction: { root: true, handler (namespacedContext, payload) { ... } // -\u003e 'someAction' } } } } } ","date":"2020-12-14","objectID":"/vue/:23:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"带命名空间的绑定函数 当使用 mapState, mapGetters, mapActions 和 mapMutations 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐： computed: { ...mapState({ a: state =\u003e state.some.nested.module.a, b: state =\u003e state.some.nested.module.b }) }, methods: { ...mapActions([ 'some/nested/module/foo', // -\u003e this['some/nested/module/foo']() 'some/nested/module/bar' // -\u003e this['some/nested/module/bar']() ]) } 对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为： computed: { ...mapState('some/nested/module', { a: state =\u003e state.a, b: state =\u003e state.b }) }, methods: { ...mapActions('some/nested/module', [ 'foo', // -\u003e this.foo() 'bar' // -\u003e this.bar() ]) } } 而且，你可以通过使用 createNamespacedHelpers 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数： import { createNamespacedHelpers } from 'vuex' const { mapState, mapActions } = createNamespacedHelpers('some/nested/module') export default { computed: { // 在 `some/nested/module` 中查找 ...mapState({ a: state =\u003e state.a, b: state =\u003e state.b }) }, methods: { // 在 `some/nested/module` 中查找 ...mapActions([ 'foo', 'bar' ]) } } ","date":"2020-12-14","objectID":"/vue/:24:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"给插件开发者的注意事项 如果你开发的插件（Plugin） 提供了模块并允许用户将其添加到 Vuex store，可能需要考虑模块的空间名称问题。对于这种情况，你可以通过插件的参数对象来允许用户指定空间名称： // 通过插件的参数对象得到空间名称 // 然后返回 Vuex 插件函数 export function createPlugin (options = {}) { return function (store) { // 把空间名字添加到插件模块的类型（type）中去 const namespace = options.namespace || '' store.dispatch(namespace + 'pluginAction') } } ","date":"2020-12-14","objectID":"/vue/:25:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"模块动态注册 在 store 创建之后，你可以使用 store.registerModule 方法注册模块： import Vuex from 'vuex' const store = new Vuex.Store({ /* 选项 */ }) // 注册模块 `myModule` store.registerModule('myModule', { // ... }) // 注册嵌套模块 `nested/myModule` store.registerModule(['nested', 'myModule'], { // ... }) 之后就可以通过 store.state.myModule 和 store.state.nested.myModule 访问模块的状态。 模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，vuex-router-sync 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。 你也可以使用 store.unregisterModule(moduleName) 来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）。 注意，你可以通过 store.hasModule(moduleName) 方法检查该模块是否已经被注册到 store。 ","date":"2020-12-14","objectID":"/vue/:26:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"保留 state 在注册一个新 module 时，你很有可能想保留过去的 state，例如从一个服务端渲染的应用保留 state。你可以通过 preserveState 选项将其归档：store.registerModule('a', module, { preserveState: true })。 当你设置 preserveState: true 时，该模块会被注册，action、mutation 和 getter 会被添加到 store 中，但是 state 不会。这里假设 store 的 state 已经包含了这个 module 的 state 并且你不希望将其覆写。 ","date":"2020-12-14","objectID":"/vue/:27:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["前端"],"content":"模块重用 有时我们可能需要创建一个模块的多个实例，例如： 创建多个 store，他们公用同一个模块 (例如当 runInNewContext 选项是 false 或 once 时，为了在服务端渲染中避免有状态的单例) 在一个 store 中多次注册同一个模块 如果我们使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时 store 或模块间数据互相污染的问题。 实际上这和 Vue 组件内的 data 是同样的问题。因此解决办法也是相同的——使用一个函数来声明模块状态（仅 2.3.0+ 支持）： const MyReusableModule = { state: () =\u003e ({ foo: 'bar' }), // mutation, action 和 getter 等等... } ","date":"2020-12-14","objectID":"/vue/:28:0","tags":["前端","学习方法","vue","vuex"],"title":"vuex教程","uri":"/vue/"},{"categories":["随笔","学习"],"content":"介绍 视频剪辑（ps,pr 学习）doyoudo 开发者 书栈网 学习外语 多邻国 ","date":"2020-12-11","objectID":"/3%E4%B8%AA%E6%9C%89%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/:0:0","tags":["随笔","网站","学习"],"title":"3个有用的网站","uri":"/3%E4%B8%AA%E6%9C%89%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/"},{"categories":["学习"],"content":"代码 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 *** 分割线 ~~*斜体文字*~~ \u003cu\u003e_斜体文字_\u003c/u\u003e **粗体文字** __粗体文字__ ***斜粗体文字*** ___斜粗体文字___[^1]。 [^1]: 你好啊这是定义的值 *** * * * ***** * 第一列 * 第二列 * 第三列 + 第一列 + 第二列 + 第三列 1. 第一列啊 1.1 中级 2. 第二列 * 初级 3. 第三列 * 啊啊啊 \u003e 区块引用 \u003e \u003e 菜鸟 # 区块使用列表 \u003e 区块中使用列表 1. 你好 1.1 你在干什么 2. 啊啊啊 1.2 我在想你 3. 不知道 `printf()` 函数 $(document).ready(function () { alert('RUNOOB'); }); 这是一个连接[百度](www.baidu.com) ![照片](http://static.runoob.com/images/runoob-logo.png) \u003cimg src=\"http://static.runoob.com/images/runoob-logo.png\" width=\"50%\"\u003e | 表头 | 表头 | | --- |---| |单元格 |单元格 | |单元格|单元格| | :--- |---:| | 表头 | 表头 | 以下是效果 一级标题 ","date":"2020-12-11","objectID":"/markdown%E5%AD%A6%E4%B9%A0/:0:0","tags":["学习","md"],"title":"markdown 学习","uri":"/markdown%E5%AD%A6%E4%B9%A0/"},{"categories":["学习"],"content":"二级标题 ","date":"2020-12-11","objectID":"/markdown%E5%AD%A6%E4%B9%A0/:1:0","tags":["学习","md"],"title":"markdown 学习","uri":"/markdown%E5%AD%A6%E4%B9%A0/"},{"categories":["学习"],"content":"三级标题 四级标题 五级标题 六级标题 *** 分割线 斜体文字 斜体文字 粗体文字 粗体文字 斜粗体文字 斜粗体文字1。 第一列 第二列 第三列 第一列 第二列 第三列 第一列啊 1.1 中级 第二列 初级 第三列 啊啊啊 区块引用 菜鸟 区块使用列表 区块中使用列表 你好 1.1 你在干什么 啊啊啊 1.2 我在想你 不知道 printf() 函数 $(document).ready(function () { alert(‘RUNOOB’); }); 这是一个连接百度 表头 表头 单元格 单元格 单元格 单元格 表头 表头 你好啊这是定义的值 ↩︎ ","date":"2020-12-11","objectID":"/markdown%E5%AD%A6%E4%B9%A0/:1:1","tags":["学习","md"],"title":"markdown 学习","uri":"/markdown%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"导出数据 ","date":"2020-12-11","objectID":"/mysql%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/:0:0","tags":["数据库","MySQL","命令","导（入/出）"],"title":"MySQL 导(入,出)数据","uri":"/mysql%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/"},{"categories":["数据库"],"content":"使用 SELECT … INTO OUTFILE 语句导出数据 以下实例中我们将数据表 runoob_tbl 数据导出到 /tmp/runoob.txt 文件中: SELECT * FROM runoob_tbl INTO OUTFILE '/tmp/runoob.txt'; 你可以通过命令选项来设置数据输出的指定格式，以下实例为导出 CSV 格式： SELECT * FROM passwd INTO OUTFILE '/tmp/runoob.txt' FIELDS TERMINATED BY ',' ENCLOSED BY '\"' LINES TERMINATED BY '\\r\\n'; 在下面的例子中，生成一个文件，各值用逗号隔开。这种格式可以被许多程序使用。 SELECT a,b,a+b INTO OUTFILE '/tmp/result.text' FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '\\n' FROM test_table; ","date":"2020-12-11","objectID":"/mysql%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/:1:0","tags":["数据库","MySQL","命令","导（入/出）"],"title":"MySQL 导(入,出)数据","uri":"/mysql%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/"},{"categories":["数据库"],"content":"SELECT … INTO OUTFILE 语句有以下属性: LOAD DATA INFILE是SELECT ... INTO OUTFILE的逆操作，SELECT句法。 为了将一个数据库的数据写入一个文件，使用SELECT ... INTO OUTFILE， 为了将文件读回数据库，使用LOAD DATA INFILE。 SELECT...INTO OUTFILE 'file_name'形式的SELECT 可以把被选择的行写入一个文件中。该文件被创建到服务器主机上， 因此您必须拥有FILE权限，才能使用此语法。 输出不能是一个已存在的文件。防止文件数据被篡改。 你需要有一个登陆服务器的账号来检索文件。否则 SELECT ... INTO OUTFILE 不会起任何作用。 在UNIX中，该文件被创建后是可读的，权限由MySQL服务器所拥有。 这意味着，虽然你就可以读取该文件，但可能无法将其删除。 ","date":"2020-12-11","objectID":"/mysql%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/:1:1","tags":["数据库","MySQL","命令","导（入/出）"],"title":"MySQL 导(入,出)数据","uri":"/mysql%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/"},{"categories":["数据库"],"content":"导出库表(mysqldump) mysqldump -u用户名 -p密码 -h主机 数据库 a -w “sql条件” –lock-all-tables \u003e 路径 mysqldump -hhostname -uusername -p dbname tbname\u003exxxx.sql ** 按指定条件导出数据库表内容。(-w选项 –where) mysqldump -hhostname -uusername-p dbname tbname -w'id \u003e= 1 and id\u003c= 10000'--skip-lock-tables \u003e xxxx.sql 或这下一行 mysqldump -hhostname -uusername -p dbname tbname --where='unit_id \u003e= 1 and unit_id \u003c= 10000'\u003e ~/xxxx.sql ","date":"2020-12-11","objectID":"/mysql%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/:2:0","tags":["数据库","MySQL","命令","导（入/出）"],"title":"MySQL 导(入,出)数据","uri":"/mysql%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/"},{"categories":["数据库"],"content":"mysqldump导出库表详细举例 导出整个数据库 mysqldump -u 用户名 -p数据库名 \u003e 导出的文件名 mysqldump -u breezelark-p mydb \u003e mydb.sql 导出一个表(包括数据结构及数据) mysqldump -u 用户名 -p数据库名 表名\u003e 导出的文件名 mysqldump -u lingxi -p mydb mytb\u003e mytb.sql 导出一个数据库结构(无数据只有结构) mysqldump -u lingxi -p -d --add-drop-table mydb \u003emydb.sql -d 没有数据–add-drop-table 在每个create语句之前增加一个drop table 导入数据 mysql -h主机地址 -u用户名 -p用户密码，文件形式。(shell命令行) mysql -u root -p dbname \u003c filename.sql 直接放在命令行(shell命令行)执行一个sql mysql -hhostname -uusername -p dbname -e 'select * from tbname limit 1' 执行后命令行会提示输入数据库密码。 把SQL作为一个输入给MYSQL(shell命令行) echo 'select id from dbname.tbname where id = 1;' | mysql -hhostname -ureadonly -preadonly dbname \u003e xxxx.sql 进入mysql数据库(数据库中执行SQL文件) source xxx.sql ","date":"2020-12-11","objectID":"/mysql%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/:2:1","tags":["数据库","MySQL","命令","导（入/出）"],"title":"MySQL 导(入,出)数据","uri":"/mysql%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/"},{"categories":["数据库"],"content":"解决方法 用PL/SQL连接Oracle数据库，输入登录名和密码后，提示如下错误： ora-01033:oracle initialization or shutdown in progress ； 第一步，运行cmd，输入sqlplus /nolog，如图 第二步、SQL\u003econnect / as sysdba 第三步、SQL\u003eshutdown normal 第四步、SQL\u003estartup mount 第五步、SQL\u003ealter database open; ","date":"2020-12-11","objectID":"/ora-01033/:0:0","tags":["数据库","异常"],"title":"ORA-01033:oracle initialization or shutdown in progress 解决办法","uri":"/ora-01033/"},{"categories":["数据库"],"content":"提示: 第1 行出现错误:ORA-01157 : 无法标识/锁定数据文件12 - 请参阅 DBWR 跟踪文件 ORA-01110 数据文件12: ‘'。。。’' ps: 这个提示文件部分（12）根据每个人不同情况有点差别。 第六步、SQL\u003ealter database datafile 12 offline drop; 第七步、重复使用第五第六步（一直循环这个语句，直至不再提示错误），直到出现“数据库已更改”的提示，然 后如下图， 第八步、继续执行shutdown normal，startup就OK啦 已经解决完成，现在可以关闭重新登录下PLSQL了。 ","date":"2020-12-11","objectID":"/ora-01033/:1:0","tags":["数据库","异常"],"title":"ORA-01033:oracle initialization or shutdown in progress 解决办法","uri":"/ora-01033/"},{"categories":["数据库"],"content":"Oracle中用exp/imp命令参数详解 ","date":"2020-12-11","objectID":"/expandimp/:0:0","tags":["数据库","Oracle","exp/imp","命令","导（入/出）"],"title":"Oracle中用exp/imp命令参数详解【转】","uri":"/expandimp/"},{"categories":["数据库"],"content":"1.【用 exp 数 据 导 出】： ","date":"2020-12-11","objectID":"/expandimp/:1:0","tags":["数据库","Oracle","exp/imp","命令","导（入/出）"],"title":"Oracle中用exp/imp命令参数详解【转】","uri":"/expandimp/"},{"categories":["数据库"],"content":"1.1 将数据库TEST完全导出,用户名system 密码manager 导出到D:\\daochu.dmp中 exp system/manager@TEST rows=y indexes=y compress=n buffer=65536 feedback=100000full=y file=d:\\daochu.dmp log=d:\\daochulog.txt owner=(ECC_BIZ,ECC_CUSTOMER) 关键字 说明 默认 USERID 用户名/口令 — FULL 导出整个文件 (N) BUFFER 数据缓冲区的大小 — OWNER 导出指定的所有者用户名列表 — FILE 输出文件 (EXPDAT.DMP) TABLES 导出指定的表名列表 — COMPRESS 是否压缩导出的文件 (Y) RECORDLENGTH IO 记录的长度 — GRANTS 导出权限 (Y) INCTYPE 增量导出类型 — INDEXES 导出索引 (Y) RECORD 跟踪增量导出 (Y) ROWS 导出数据行 (Y) PARFILE 参数文件名 — CONSTRAINTS 导出限制 (Y) CONSISTENT 交叉表一致性 — LOG 屏幕输出的日志文件 — STATISTICS 分析对象(ESTIMATE) — DIRECT 直接路径 — TRIGGERS 导出触发器 (Y) FEEDBACK 显示每 x 行 (0) 的进度 — FILESIZE 各转储文件的最大尺寸 — QUERY 选定导出表子集的子句 — TRANSPORT_TABLESPACE 导出可传输的表空间元数据 — TABLESPACES 导出指定的表空间列表 — ","date":"2020-12-11","objectID":"/expandimp/:1:1","tags":["数据库","Oracle","exp/imp","命令","导（入/出）"],"title":"Oracle中用exp/imp命令参数详解【转】","uri":"/expandimp/"},{"categories":["数据库"],"content":"1.2. 将数据库中system用户与sys用户的表导出 exp system/manager@TEST file=d:\\daochu.dmp owner=(system,sys) ","date":"2020-12-11","objectID":"/expandimp/:1:2","tags":["数据库","Oracle","exp/imp","命令","导（入/出）"],"title":"Oracle中用exp/imp命令参数详解【转】","uri":"/expandimp/"},{"categories":["数据库"],"content":"1.3. 将数据库中的表table1 、table2导出 exp system/manager@TEST file=d:\\daochu.dmp tables=(table1,table2) ","date":"2020-12-11","objectID":"/expandimp/:1:3","tags":["数据库","Oracle","exp/imp","命令","导（入/出）"],"title":"Oracle中用exp/imp命令参数详解【转】","uri":"/expandimp/"},{"categories":["数据库"],"content":"1.4. 将数据库中的表table1中的字段filed1以”00″打头的数据导出 exp system/manager@TEST file=d:\\daochu.dmp tables=(table1) query=\\” where filed1like \u0026apos;00%\u0026apos;\\” 上面是常用的导出，对于压缩我不太在意，用winzip把dmp文件可以很好的压缩。不过在上面命令后面 加上 compress=y 就可以了 ","date":"2020-12-11","objectID":"/expandimp/:1:4","tags":["数据库","Oracle","exp/imp","命令","导（入/出）"],"title":"Oracle中用exp/imp命令参数详解【转】","uri":"/expandimp/"},{"categories":["数据库"],"content":"2.【用 imp 数 据 导 入】： ","date":"2020-12-11","objectID":"/expandimp/:2:0","tags":["数据库","Oracle","exp/imp","命令","导（入/出）"],"title":"Oracle中用exp/imp命令参数详解【转】","uri":"/expandimp/"},{"categories":["数据库"],"content":"2.1 将D:\\daochu.dmp 中的数据导入 TEST数据库中。 imp system/manager@TEST ignore=y full=y file=d:\\daochu.dmp log=d:\\daoru.txt 关键字 说明 默认 USERID 用户名/口令 FULL 导入整个文件 (N) BUFFER 数据缓冲区大小 FROMUSER 所有人用户名列表 FILE 输入文件 (EXPDAT.DMP) TOUSER 用户名列表 SHOW 只列出文件内容 (N) TABLES 表名列表 IGNORE 忽略创建错误 (N) RECORDLENGTH IO记录的长度 GRANTS 导入权限 (Y) INCTYPE 增量导入类型 INDEXES 导入索引 (Y) COMMIT 提交数组插入 (N) ROWS 导入数据行 (Y) PARFILE 参数文件名 LOG 屏幕输出的日志文件 CONSTRAINTS 导入限制 (Y) DESTROY 覆盖表空间数据文件 (N) INDEXFILE 将表/索引信息写入指定的文件 SKIP_UNUSABLE_INDEXES 跳过不可用索引的维护 (N) FEEDBACK 每 x 行显示进度 TOID_NOVALIDATE 跳过指定类型 ID 的验证 FILESIZE 每个转储文件的最大大小 STATISTICS 始终导入预计算的统计信息 RESUMABLE 在遇到有关空间的错误时挂起 RESUMABLE_NAME 用来标识可恢复语句的文本字符串 RESUMABLE_TIMEOUT RESUMABLE 的等待时间 COMPILE 编译过程, 程序包和函数 (Y) STREAMS_CONFIGURATION 导入 Streams 的一般元数据 (Y) STREAMS_INSTANITATION 导入 Streams 的实例化元数据 (N) TRANSPORT_TABLESPACE 导入可传输的表空间元数据 TABLESPACES 将要传输到数据库的表空间 DATAFILES 将要传输到数据库的数据文件 TTS_OWNERS 拥有可传输表空间集中数据的用户 ","date":"2020-12-11","objectID":"/expandimp/:2:1","tags":["数据库","Oracle","exp/imp","命令","导（入/出）"],"title":"Oracle中用exp/imp命令参数详解【转】","uri":"/expandimp/"},{"categories":["数据库"],"content":"3. imp 演示 ","date":"2020-12-11","objectID":"/expandimp/:3:0","tags":["数据库","Oracle","exp/imp","命令","导（入/出）"],"title":"Oracle中用exp/imp命令参数详解【转】","uri":"/expandimp/"},{"categories":["数据库"],"content":"3.1. 获取帮助 imp help=y ","date":"2020-12-11","objectID":"/expandimp/:3:1","tags":["数据库","Oracle","exp/imp","命令","导（入/出）"],"title":"Oracle中用exp/imp命令参数详解【转】","uri":"/expandimp/"},{"categories":["数据库"],"content":"3.2. 导入一个完整数据库 imp system/manager file=bible_db log=dible_db full=y ignore=y ","date":"2020-12-11","objectID":"/expandimp/:3:2","tags":["数据库","Oracle","exp/imp","命令","导（入/出）"],"title":"Oracle中用exp/imp命令参数详解【转】","uri":"/expandimp/"},{"categories":["数据库"],"content":"3.3. 导入一个或一组指定用户所属的全部表、索引和其他对象 imp system/manager file=seapark log=seapark fromuser=seapark imp system/manager file=seapark log=seapark fromuser=(seapark,amy,amyc,harold) ","date":"2020-12-11","objectID":"/expandimp/:3:3","tags":["数据库","Oracle","exp/imp","命令","导（入/出）"],"title":"Oracle中用exp/imp命令参数详解【转】","uri":"/expandimp/"},{"categories":["数据库"],"content":"3.4. 将一个用户所属的数据导入另一个用户 imp system/manager file=tank log=tank fromuser=seapark touser=seapark_copy imp system/manager file=tank log=tank fromuser=(seapark,amy) touser=(seapark1, amy1) ","date":"2020-12-11","objectID":"/expandimp/:3:4","tags":["数据库","Oracle","exp/imp","命令","导（入/出）"],"title":"Oracle中用exp/imp命令参数详解【转】","uri":"/expandimp/"},{"categories":["数据库"],"content":"3.5. 导入一个表 imp system/manager file=tank log=tank fromuser=seapark TABLES=(a,b) ","date":"2020-12-11","objectID":"/expandimp/:3:5","tags":["数据库","Oracle","exp/imp","命令","导（入/出）"],"title":"Oracle中用exp/imp命令参数详解【转】","uri":"/expandimp/"},{"categories":["数据库"],"content":"3.6. 从多个文件导入 imp system/manager file=(paycheck_1,paycheck_2,paycheck_3,paycheck_4) log=paycheck,filesize=1G full=y ","date":"2020-12-11","objectID":"/expandimp/:3:6","tags":["数据库","Oracle","exp/imp","命令","导（入/出）"],"title":"Oracle中用exp/imp命令参数详解【转】","uri":"/expandimp/"},{"categories":["数据库"],"content":"3.7. 使用参数文件 imp system/manager parfile=bible_tables.par bible_tables.par参数文件： #Import the sample tables used for the Oracle8i Database Administrator's #Bible. fromuser=seapark touser=seapark_copy file=seapark log=seapark_import ","date":"2020-12-11","objectID":"/expandimp/:3:7","tags":["数据库","Oracle","exp/imp","命令","导（入/出）"],"title":"Oracle中用exp/imp命令参数详解【转】","uri":"/expandimp/"},{"categories":["数据库"],"content":"3.8. 增量导入(9i中已经取消) imp system./manager inctype= RECTORE FULL=Y FILE=A 本文章转载于:大卫.宋博客 ","date":"2020-12-11","objectID":"/expandimp/:3:8","tags":["数据库","Oracle","exp/imp","命令","导（入/出）"],"title":"Oracle中用exp/imp命令参数详解【转】","uri":"/expandimp/"},{"categories":["数据库"],"content":"增加数据库空间方法 \"ORA-01654: 索引。。。无法通过8192（在表空间。。。中）扩展\" ","date":"2020-12-11","objectID":"/%E5%A2%9E%E5%8A%A0oracle-%E8%A1%A8%E7%A9%BA%E9%97%B4/:0:0","tags":["数据库","维护","ORACLE"],"title":"增加 ORACLE 数据库空间","uri":"/%E5%A2%9E%E5%8A%A0oracle-%E8%A1%A8%E7%A9%BA%E9%97%B4/"},{"categories":["数据库"],"content":"查询方法 SELECT UPPER(F.TABLESPACE_NAME) \"表空间名\", D.TOT_GROOTTE_MB \"表空间大小(M)\", D.TOT_GROOTTE_MB - F.TOTAL_BYTES \"已使用空间(M)\", TO_CHAR(ROUND((D.TOT_GROOTTE_MB - F.TOTAL_BYTES) / D.TOT_GROOTTE_MB * 100,2),'990.99') \"使用比\", F.TOTAL_BYTES \"空闲空间(M)\", F.MAX_BYTES \"最大块(M)\" FROM ( SELECT TABLESPACE_NAME, ROUND(SUM(BYTES) / (1024 * 1024), 2) TOTAL_BYTES, ROUND(MAX(BYTES) / (1024 * 1024), 2) MAX_BYTES FROM SYS.DBA_FREE_SPACE GROUP BY TABLESPACE_NAME ) F, ( SELECT DD.TABLESPACE_NAME, ROUND(SUM(DD.BYTES) / (1024 * 1024), 2) TOT_GROOTTE_MB FROM SYS.DBA_DATA_FILES DD GROUP BY DD.TABLESPACE_NAME ) D WHERE D.TABLESPACE_NAME = F.TABLESPACE_NAME ORDER BY 4 DESC; -- 查看表空间文件 select file_name,tablespace_name,bytes from dba_data_files; ","date":"2020-12-11","objectID":"/%E5%A2%9E%E5%8A%A0oracle-%E8%A1%A8%E7%A9%BA%E9%97%B4/:1:0","tags":["数据库","维护","ORACLE"],"title":"增加 ORACLE 数据库空间","uri":"/%E5%A2%9E%E5%8A%A0oracle-%E8%A1%A8%E7%A9%BA%E9%97%B4/"},{"categories":["数据库"],"content":"手动给该表空间添加数据文件： ALTER TABLESPACE \"WORK\" ADD DATAFILE '*.DBF' SIZE 10G AUTOEXTEND ON NEXT 50M MAXSIZE UNLIMITED; ","date":"2020-12-11","objectID":"/%E5%A2%9E%E5%8A%A0oracle-%E8%A1%A8%E7%A9%BA%E9%97%B4/:2:0","tags":["数据库","维护","ORACLE"],"title":"增加 ORACLE 数据库空间","uri":"/%E5%A2%9E%E5%8A%A0oracle-%E8%A1%A8%E7%A9%BA%E9%97%B4/"},{"categories":["数据库"],"content":" 查询 oracle的连接数 select count(*) from v$session; 查询oracle的并发连接数 select count(*) from v$session where status='ACTIVE'; 查看不同用户的连接数 select username,count(username) from v$session where username is not null group by username; 查看所有用户： select * from all_users; 查看用户或角色系统权限(直接赋值给用户或角色的系统权限)： select * from dba_sys_privs; select * from user_sys_privs; 查看角色(只能查看登陆用户拥有的角色)所包含的权限 select * from role_sys_privs; 查看用户对象权限： select * from dba_tab_privs; select * from all_tab_privs; select * from user_tab_privs; 查看所有角色： select * from dba_roles; 查看用户或角色所拥有的角色： select * from dba_role_privs; select * from user_role_privs; 查看哪些用户有sysdba或sysoper系统权限(查询时需要相应权限) select * from V$PWFILE_USERS; select count(*) from v$process –当前的连接数 select value from v$parameter where name = 'processes' –数据库允许的最大连接数 修改最大连接数: alter system set processes = 300 scope = spfile; 重启数据库: shutdown immediate; startup; –查看当前有哪些用户正在使用数据 SELECT osuser, a.username,cpu_time/executions/1000000||'s', sql_fulltext,machine from v$session a, v$sqlarea b where a.sql_address =b.address order by cpu_time/executions desc; select count(*) from v$session #连接数 select count(*) from v$session where status='ACTIVE'　#并发连接数 show parameter processes #最大连接 alter system set processes = value scope = spfile;重启数据库 #修改连接 SQL\u003e Select count(*) from v$session where status='ACTIVE' ; COUNT(*) ---------- 20 SQL\u003e Select count(*) from v$session; COUNT(*) ---------- 187 SQL\u003e show parameter processes; NAME TYPE VALUE ------------------------------------ ----------- ---------- aq_tm_processes integer 0 db_writer_processes integer 1 gcs_server_processes integer 0 job_queue_processes integer 10 log_archive_max_processes integer 2 processes integer 450 SQL\u003e 并发指active,I SEE SQL\u003e select count(*) from v$session #连接数 SQL\u003e Select count(*) from v$session where status='ACTIVE'　#并发连接数 SQL\u003e show parameter processes #最大连接 SQL\u003e alter system set processes = value scope = spfile;重启数据库 #修改连接 unix 1个用户session 对应一个操作系统 process 而 windows体现在线程 DBA要定时对数据库的连接情况进行检查，看与数据库建立的会话数目是不是正常，如果建立了过多的连接，会消耗数据库的资源。同时，对一些“挂死”的连接，可能会需要 DBA手工进行清理。 以下的SQL语句列出当前数据库建立的会话情况: select sid,serial#,username,program,machine,status from v$session; 输出结果为: SID SERIAL# USERNAME PROGRAM MACHINE STATUS ---- ------- ---------- ----------- --------------- -------- 1 ORACLE.EXE WORK3 ACTIVE 1 ORACLE.EXE WORK3 ACTIVE 1 ORACLE.EXE WORK3 ACTIVE 1 ORACLE.EXE WORK3 ACTIVE 3 ORACLE.EXE WORK3 ACTIVE 1 ORACLE.EXE WORK3 ACTIVE 1 ORACLE.EXE WORK3 ACTIVE 27 SYS SQLPLUS.EXE WORKGROUP\\\\WORK3 ACTIVE 5 DBSNMP dbsnmp.exe WORKGROUP\\\\WORK3 INACTIVE 其中， SID 会话(session)的ID号; SERIAL# 会话的序列号，和SID一起用来唯一标识一个会话; USERNAME 建立该会话的用户名; PROGRAM 这个会话是用什么工具连接到数据库的; STATUS 当前这个会话的状态，ACTIVE表示会话正在执行某些任务，INACTIVE 表示当前会话没有执行任何操作; 如果DBA要手工断开某个会话，则执行: alter system kill session \\'SID,SERIAL#\\' sql语句 SQL语句如下： SELECT username, machine, program, status, COUNT (machine) AS 连接数量 FROM v$session GROUP BY username, machine, program, status ORDER BY machine; 显示结果（每个人的机器上会不同） SCHNEIDER|WORKGROUD\\WANGZHENG|TOAD.exe|ACTIVE|1 SCHNEIDER|WORKGROUP\\597728AA514F49D|sqlplusw.exe|INACTIVE|1 |WWW-Q6ZMR2OIU9V|ORACLE.EXE|ACTIVE|8 PUBLIC|||INACTIVE|0 按主机名查询 SELECT COUNT(*) FROM V$SESSION WHERE MACHINE = 'DXMH'; ‘DXMH‘为主机名 数据恢复语句 create table informationlaw_bak as select * from informationlaw as of TIMESTAMP to_timestamp('20121126 103435','yyyymmdd hh24miss'); //按机器名分组查 select username,machine,count(username) from v$session where username is not null group by username,machine; 本文章转载于:PeterWang2018 ","date":"2020-12-11","objectID":"/%E6%9F%A5%E7%9C%8Boracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%95%B0%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%88%B7/:0:0","tags":["数据库","维护","ORACLE"],"title":"查看oracle数据库的连接数以及用户【转】","uri":"/%E6%9F%A5%E7%9C%8Boracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%95%B0%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%88%B7/"},{"categories":["前端"],"content":"介绍： 本站使用小人特效 依赖 jquery.js 源代码 /** * 小人 */ function f2() { var S_width; var S_height; var isTouch = 'ontouchstart' in window, START_EVENT = isTouch ? 'touchstart' : 'mousedown', MOVE_EVENT = isTouch ? 'touchmove' : 'mousemove', END_EVENT = isTouch ? 'touchend' : 'mouseup'; var powder = []; //speed:7 var man = { x: 30, y: 110, step: 0, type: 'teststyle', speed: 7, armlength: 10, leglength: 15, head: 8, body: 25 }; var isspread = false; var ispowder = true; //var teststyle=[{armleft0:-45,armleft1:-20,armright0:45,armright1:20,legleft0:-45,legleft1:-20,legright0:45,legright1:20},{armleft0:-60,armleft1:-30,armright0:30,armright1:5,legleft0:-60,legleft1:-30,legright0:30,legright1:5},{armleft0:-70,armleft1:-50,armright0:60,armright1:70,legleft0:-30,legleft1:-50,legright0:70,legright1:20},{armleft0:-10,armleft1:-80,armright0:90,armright1:40,legleft0:-20,legleft1:-60,legright0:90,legright1:10},{armleft0:-80,armleft1:-60,armright0:80,armright1:50,legleft0:-30,legleft1:-40,legright0:90,legright1:80},{armleft0:-60,armleft1:-70,armright0:90,armright1:10,legleft0:-90,legleft1:-60,legright0:40,legright1:70}]; //不行 var teststyle = [ { armleft0: -45, armleft1: -65, armright0: 45, armright1: 25, legleft0: -45, legleft1: -65, legright0: 45, legright1: 25 }, { armleft0: -30, armleft1: -50, armright0: 30, armright1: 10, legleft0: -30, legleft1: -50, legright0: 30, legright1: 10 }, { armleft0: -15, armleft1: -35, armright0: 15, armright1: -5, legleft0: -15, legleft1: -35, legright0: 15, legright1: -5 }, { armleft0: 0, armleft1: -20, armright0: 0, armright1: -20, legleft0: 0, legleft1: -20, legright0: 0, legright1: -20 }, { armleft0: 15, armleft1: -5, armright0: -15, armright1: -35, legleft0: 15, legleft1: -5, legright0: -15, legright1: -35 }, { armleft0: 30, armleft1: 10, armright0: -30, armright1: -50, legleft0: 30, legleft1: 10, legright0: -30, legright1: -50 } ]; // var teststyle1 = [ { armleft0: -30, armleft1: 0, armright0: 30, armright1: 0, legleft0: -5, legleft1: 0, legright0: 5, legright1: 0 }, { armleft0: -30, armleft1: 0, armright0: 15, armright1: 0, legleft0: -5, legleft1: 0, legright0: 45, legright1: 0 }, { armleft0: -35, armleft1: 0, armright0: 15, armright1: 0, legleft0: -5, legleft1: 0, legright0: 72, legright1: 0 }, { armleft0: -35, armleft1: 0, armright0: 0, armright1: 0, legleft0: -5, legleft1: 0, legright0: 97, legright1: 81 }, { armleft0: -40, armleft1: 0, armright0: -15, armright1: 0, legleft0: -5, legleft1: 0, legright0: 111, legright1: 108 }, { armleft0: -40, armleft1: 0, armright0: -15, armright1: 0, legleft0: -5, legleft1: 0, legright0: 135, legright1: 135 }, { armleft0: -35, armleft1: 0, armright0: 0, armright1: 0, legleft0: -5, legleft1: 0, legright0: 97, legright1: 81 }, { armleft0: -30, armleft1: 0, armright0: 15, armright1: 0, legleft0: -5, legleft1: 0, legright0: 45, legright1: 0 }, { armleft0: -30, armleft1: 0, armright0: 30, armright1: 0, legleft0: -5, legleft1: 0, legright0: 5, legright1: 0 }, { armleft0: -51, armleft1: -27, armright0: 51, armright1: 41, legleft0: -22, legleft1: -18, legright0: 22, legright1: 18 }, { armleft0: -72, armleft1: -54, armright0: 72, armright1: 82, legleft0: -39, legleft1: -36, legright0: 39, legright1: 36 }, { armleft0: -93, armleft1: -81, armright0: 93, armright1: 123, legleft0: -56, legleft1: -54, legright0: 56, legright1: 54 }, { armleft0: -114, armleft1: -108, armright0: -114, armright1: 164, legleft0: -73, legleft1: -72, legright0: 73, legright1: 72 }, { armleft0: -135, armleft1: -135, armright0: 135, armright1: 164, legleft0: -90, legleft1: -90, legright0: 90, legright1: 90 }, { armleft0: -135, armleft1: -135, armright0: 135, armright1: 164, legleft0: -90, legleft1: -90, legright0: 90, legright1: 90 }, { armleft0: -135, armleft1: -135, armright0: 135, armright1: 164, legleft0: -90, legleft1: -90, legright0: 90, legright1: 90 }, { armleft0: -114, armleft1: -108, armright0: -114, armright1: 164, legleft0: -73, legleft1: -72, legright0: 73, legright1: 72 }, { armleft0: -72, armleft1: ","date":"2020-12-10","objectID":"/%E7%89%B9%E6%95%88%E5%B0%8F%E4%BA%BA/:0:0","tags":["前端","特效","canvas"],"title":"canvas特效小人","uri":"/%E7%89%B9%E6%95%88%E5%B0%8F%E4%BA%BA/"},{"categories":["前端"],"content":"map 是人物的各项属性。 var man = { x: 30, // 人物X向位置 y: 110, // 人物Y向位置 step: 0, // 人物初始化步 type: \"teststyle\", // 类型，teststyle 走路 teststyle1 跳舞 speed: 7, // 人物初始化移动速度 armlength: 10, // 人物手臂长度 leglength: 15, // 人物腿长 head: 8, // 人物头部大小 body: 25 // 人物主体躯干 } ","date":"2020-12-10","objectID":"/%E7%89%B9%E6%95%88%E5%B0%8F%E4%BA%BA/:1:0","tags":["前端","特效","canvas"],"title":"canvas特效小人","uri":"/%E7%89%B9%E6%95%88%E5%B0%8F%E4%BA%BA/"},{"categories":["前端"],"content":"介绍： 本站使用鼠标特效 依赖 jquery.js 源代码 /** * 鼠标特效 a */ function f1() { /* 鼠标特效 */ var a_idx = 0; jQuery(document).ready(function ($) { $(\"body\").click(function (e) { var a = new Array(\"❤富强❤\", \"❤民主❤\", \"❤文明❤\", \"❤和谐❤\", \"❤自由❤\", \"❤平等❤\", \"❤公正❤\", \"❤法治❤\", \"❤爱国❤\", \"❤敬业❤\", \"❤诚信❤\", \"❤友善❤\"); var $i = $(\"\u003cspan\u003e\u003c/span\u003e\").text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css({ \"z-index\": 999999999999999999999999999999999999999999999999999999999999999999999, \"top\": y - 20, \"left\": x, \"position\": \"absolute\", \"font-weight\": \"bold\", \"color\": \"rgb(\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \")\" }); $(\"body\").append($i); $i.animate({ \"top\": y - 180, \"opacity\": 0 }, 1500, function () { $i.remove(); }); }); }); } 使用方式： 将代码复制的站中的主js中。 类似于 main.js ","date":"2020-12-10","objectID":"/%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%89%B9%E6%95%88/:0:0","tags":["前端","特效"],"title":"鼠标点击特效","uri":"/%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%89%B9%E6%95%88/"},{"categories":["前端"],"content":"介绍： 总所周知，前端开发，主要是面向用户。也就是门面。它的核心（页面，路由，请求后台） 知道了核心我们就知道该为何学习了。 ","date":"2020-12-09","objectID":"/%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF/:0:0","tags":["前端","学习方法"],"title":"前端的真正学习方法","uri":"/%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF/"},{"categories":["前端"],"content":"页面 页面其实就是显示页。比如 列表页，详情页。但是往往都是只需要显示一个页面（单页面） ","date":"2020-12-09","objectID":"/%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF/:1:0","tags":["前端","学习方法"],"title":"前端的真正学习方法","uri":"/%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF/"},{"categories":["前端"],"content":"路由 每个页面都是一个个体。有时候需要一个导航栏，用于路由。 ","date":"2020-12-09","objectID":"/%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF/:2:0","tags":["前端","学习方法"],"title":"前端的真正学习方法","uri":"/%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF/"},{"categories":["前端"],"content":"请求后台 每个页面的动态内容，基本上都是后台服务端提供。前端只需要发送请求即可。 总结 虽然我上面说的很简单，但是前端的核心也就是这3个组合。学习任何前端框架，快速的找到（如何编辑页面， 如何页面之间的路由，如何请求后台的方法）就可以使用这个框架。 （ps以上只能是浅显的使用框架，如果想深入使用还需要进一步学习！） ","date":"2020-12-09","objectID":"/%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF/:3:0","tags":["前端","学习方法"],"title":"前端的真正学习方法","uri":"/%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF/"},{"categories":["java调试"],"content":"使用代码： -Xms256m -Xmx1024m -XX:MaxNewSize=256m -XX:PermSize=64M -XX:MaxPermSize=128M ","date":"2020-12-08","objectID":"/jvm-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/:0:0","tags":["java","调试"],"title":"JVM 内存溢出","uri":"/jvm-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"},{"categories":["linux命令"],"content":"说明 每一个服务以.service结尾，一般会分为3部分：[Unit]、[Service]和[Install] vim /usr/lib/systemd/system/xxx.service [Unit] # 主要是服务说明 Description=test # 简单描述服务 After=network.target # 描述服务类别，表示本服务需要在network服务启动后在启动 Before=xxx.service # 表示需要在某些服务启动之前启动，After和Before字段只涉及启动顺序，不涉及依赖关系。 [Service] # 核心区域 Type=forking # 表示后台运行模式。 User=user # 设置服务运行的用户 Group=user # 设置服务运行的用户组 KillMode=control-group # 定义systemd如何停止服务 PIDFile=/usr/local/test/test.pid # 存放PID的绝对路径 Restart=no # 定义服务进程退出后，systemd的重启方式，默认是不重启 ExecStart=/usr/local/test/bin/startup.sh # 服务启动命令，命令需要绝对路径 PrivateTmp=true # 表示给服务分配独立的临时空间 [Install] WantedBy=multi-user.target # 多用户 ","date":"2020-12-08","objectID":"/systemctl/:0:0","tags":["linux","命令","systemctl"],"title":"systemctl使用方法","uri":"/systemctl/"},{"categories":["linux命令"],"content":"字段说明： ","date":"2020-12-08","objectID":"/systemctl/:1:0","tags":["linux","命令","systemctl"],"title":"systemctl使用方法","uri":"/systemctl/"},{"categories":["linux命令"],"content":"Type的类型有： simple(默认）：# 以ExecStart字段启动的进程为主进程 forking: # ExecStart字段以fork()方式启动，此时父进程将退出，子进程将成为主进程（后台运行）。一般都设置为forking oneshot: # 类似于simple，但只执行一次，systemd会等它执行完，才启动其他服务 dbus： # 类似于simple, 但会等待D-Bus信号后启动 notify: # 类似于simple, 启动结束后会发出通知信号，然后systemd再启动其他服务 idle： # 类似于simple，但是要等到其他任务都执行完，才会启动该服务。 ","date":"2020-12-08","objectID":"/systemctl/:1:1","tags":["linux","命令","systemctl"],"title":"systemctl使用方法","uri":"/systemctl/"},{"categories":["linux命令"],"content":"EnvironmentFile: 指定配置文件，和连词号组合使用，可以避免配置文件不存在的异常。 ","date":"2020-12-08","objectID":"/systemctl/:1:2","tags":["linux","命令","systemctl"],"title":"systemctl使用方法","uri":"/systemctl/"},{"categories":["linux命令"],"content":"Environment: 后面接多个不同的shell变量。 例如： Environment=DATA_DIR=/data/elk Environment=LOG_DIR=/var/log/elasticsearch Environment=PID_DIR=/var/run/elasticsearch EnvironmentFile=-/etc/sysconfig/elasticsearch 连词号（-）：在所有启动设置之前，添加的变量字段，都可以加上连词号 表示抑制错误，即发生错误时，不影响其他命令的执行。 比如EnviromentFile=-/etc/sysconfig/xxx 表示即使文件不存在，也不会抛异常 ","date":"2020-12-08","objectID":"/systemctl/:1:3","tags":["linux","命令","systemctl"],"title":"systemctl使用方法","uri":"/systemctl/"},{"categories":["linux命令"],"content":"KillMode的类型： control-group(默认)：# 当前控制组里的所有子进程，都会被杀掉 process: # 只杀主进程 mixed: # 主进程将收到SIGTERM信号，子进程收到SIGKILL信号 none: # 没有进程会被杀掉，只是执行服务的stop命令 ","date":"2020-12-08","objectID":"/systemctl/:1:4","tags":["linux","命令","systemctl"],"title":"systemctl使用方法","uri":"/systemctl/"},{"categories":["linux命令"],"content":"Restart的类型： no(默认值)： # 退出后无操作 on-success: # 只有正常退出时（退出状态码为0）,才会重启 on-failure: # 非正常退出时，重启，包括被信号终止和超时等 on-abnormal: # 只有被信号终止或超时，才会重启 on-abort: # 只有在收到没有捕捉到的信号终止时，才会重启 on-watchdog: # 超时退出时，才会重启 always: # 不管什么退出原因，都会重启 ","date":"2020-12-08","objectID":"/systemctl/:1:5","tags":["linux","命令","systemctl"],"title":"systemctl使用方法","uri":"/systemctl/"},{"categories":["linux命令"],"content":"对于守护进程，推荐用on-failure ","date":"2020-12-08","objectID":"/systemctl/:2:0","tags":["linux","命令","systemctl"],"title":"systemctl使用方法","uri":"/systemctl/"},{"categories":["linux命令"],"content":"RestartSec字段： 表示systemd重启服务之前，需要等待的秒数：RestartSec: 30 ","date":"2020-12-08","objectID":"/systemctl/:2:1","tags":["linux","命令","systemctl"],"title":"systemctl使用方法","uri":"/systemctl/"},{"categories":["linux命令"],"content":"各种Exec*字段： Exec* 后面接的命令，仅接受“指令 参数 参数..”格式，不能接受\u003c\u003e|\u0026等特殊字符，很多bash语法也不支持。如果想支持bash语法， **需要设置Tyep=oneshot** ExecStart： # 启动服务时执行的命令 ExecReload： # 重启服务时执行的命令 ExecStop： # 停止服务时执行的命令 ExecStartPre： # 启动服务前执行的命令 ExecStartPost：# 启动服务后执行的命令 ExecStopPost： # 停止服务后执行的命令 ","date":"2020-12-08","objectID":"/systemctl/:3:0","tags":["linux","命令","systemctl"],"title":"systemctl使用方法","uri":"/systemctl/"},{"categories":["linux命令"],"content":"WantedBy字段： multi-user.target: # 表示多用户命令行状态，这个设置很重要 graphical.target: # 表示图形用户状体，它依赖于multi-user.target systemctl 命令 systemctl daemon-reload # 重载系统服务 systemctl enable *.service # 设置某个服务开机启动 systemctl start *.service # 启动某个服务 systemctl stop *.service # 停止某个服务 systemctl reload *.service # 重启某个服务 ","date":"2020-12-08","objectID":"/systemctl/:3:1","tags":["linux","命令","systemctl"],"title":"systemctl使用方法","uri":"/systemctl/"},{"categories":["hugo"],"content":"1. 创建文章 $ hugo new *.md 解释：about.md 自动生成到了 content/about.md ","date":"2020-12-07","objectID":"/hugo-%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/:1:0","tags":["博客","hugo"],"title":"hugo 使用方法","uri":"/hugo-%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"},{"categories":["hugo"],"content":"2. 部署服务 $ hugo 解释： 使用 hugo 生成 pages 修改的文件用于显示内容 ","date":"2020-12-07","objectID":"/hugo-%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/:2:0","tags":["博客","hugo"],"title":"hugo 使用方法","uri":"/hugo-%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"},{"categories":["hugo"],"content":"3.使用皮肤 $ git clone https://hub.fastgit.org/liuzc/leaveit.git 皮肤的使用说明： https://liuzhichao.com/2018/hugo-theme-leaveit/ ","date":"2020-12-07","objectID":"/hugo-%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/:3:0","tags":["博客","hugo"],"title":"hugo 使用方法","uri":"/hugo-%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"},{"categories":["hugo"],"content":"4. 皮肤使用的一些问题 配置文件中 menu 中的是页面中的标签栏。 [[menu.main]] name = \"类型\" url = \"/categories/\" weight = 2 weight 代表标签头的位置 越小越靠前 ","date":"2020-12-07","objectID":"/hugo-%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/:4:0","tags":["博客","hugo"],"title":"hugo 使用方法","uri":"/hugo-%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"},{"categories":["hugo"],"content":"5. 文章编写时的抬头描述 --- title: \"java 远程调试\" date: \"2020-12-07\" tags: [\"java\",\"调试\"] categories: [\"java调试\"] --- title ：文件头 date: 文件创建时间 tags: 标签 —–\u003e 在配置文件中也会使用到 categories: 类型 —\u003e 在配置文件中也会使用到 配置文件设置 根目录下的 config.toml 文件是主要的配置文件。 baseURL = \"https://xiaofangkang.gitee.io/blog\" languageCode = \"en-us\" title = \"小小的交流博客\" theme = \"LeaveIt\" ","date":"2020-12-07","objectID":"/hugo-%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/:5:0","tags":["博客","hugo"],"title":"hugo 使用方法","uri":"/hugo-%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"},{"categories":["java调试"],"content":"远程JVM启用调试模式 java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=2857 -jar *.jar ","date":"2020-12-07","objectID":"/java-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:0:0","tags":["java","调试"],"title":"java 远程调试","uri":"/java-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":["java调试"],"content":"描述 -XDebug 表示虚拟机启用调试功能 -Xrunjdwp 加载JDWP transport 调试程序JVM使用的进程之间通讯方式 dt_socket socket通讯 server=y/n JVM是否需要作为调试服务器执行 address 调试服务器监听的端口号 suspend=y/n 调试客户端建立连接之后启动虚拟机 JVM启动之后用验证监听的端口号是否生效了 netstat -anp | grep 1506 tomcat 远程调试 ","date":"2020-12-07","objectID":"/java-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:1:0","tags":["java","调试"],"title":"java 远程调试","uri":"/java-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":["java调试"],"content":"windows 进入目录下的bin目录，编辑打开 startup.bat 在前面添加： SET CATALINA_OPTS=-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000 ","date":"2020-12-07","objectID":"/java-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:2:0","tags":["java","调试"],"title":"java 远程调试","uri":"/java-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":["java调试"],"content":"linux 在catalina.sh中的首行添加： CATALINA_OPTS=\"-Xdebug -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n\" idea 本地调试配置 ","date":"2020-12-07","objectID":"/java-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:3:0","tags":["java","调试"],"title":"java 远程调试","uri":"/java-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":null,"content":"关于版权: 1.本站博文采用 本文采用知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。 2.若未特别声明，您可以将本站文章用于非盈利目的，但请保留作者信息及文章原始链接。 ","date":"2020-12-07","objectID":"/about/:1:0","tags":null,"title":"个人介绍","uri":"/about/"},{"categories":null,"content":"关于我: 个人信息 email x66128@qq.com wx 技能 编程语言： java , js , html , sql , css 编程框架: Spring , springMvc , springBoot ,springcloud ….. spring全家桶 MyBatis ，MyBatis-Plus 数据库 : mysql , Oracle No 数据库： Redis 队列： ActiveMQ , RabbitMQ , Kafka , RocketMQ 定时任务 Quartz , springTask 大数据： hadoop(hdfs) 搜索引擎： solr 前端框架： vue,uniapp 前端数据图形化框架 阿里： F2,G2 等，百度： echarts 额外技能： 小程序开发 ","date":"2020-12-07","objectID":"/about/:2:0","tags":null,"title":"个人介绍","uri":"/about/"}]